<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="阳光夜风"><title>不强持有对象的集合 · 阳光夜风</title><meta name="description" content="前几天有同事在讨论想设计一个检查内存不释放的功能（主要是viewcontroller），大体思路就是每次pushviewcontroller的时候把vc加入到一个集合中，然后pop出去的时候延迟几秒之后在该集合内检查对应vc是否被释放。但是如果用普通的NSArray或者NSDictionary肯定是"><meta name="keywords" content="iOS, Apple Foundation, Machine Learning, Algorithm, LeetCode"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">阳光夜风</a></h3><div class="description"><p>上善若水 大盈若冲</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/1685261185"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/categories/">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>不强持有对象的集合</a></h3></div><div class="post-content"><p>前几天有同事在讨论想设计一个检查内存不释放的功能（主要是viewcontroller），大体思路就是每次pushviewcontroller的时候把vc加入到一个集合中，然后pop出去的时候延迟几秒之后在该集合内检查对应vc是否被释放。但是如果用普通的NSArray或者NSDictionary肯定是不行的，因为会强持有这个vc，导致一直无法释放，所以就在考虑怎么能实现一个weak的集合。</p>
<p>思路大概有两个方向：</p>
<ul>
<li>仍然使用传统的NSArray等类型，保证add进结合的时候不对元数据产生强引用</li>
<li>使用其他集合类型</li>
</ul>
<h4 id="第一个方向"><a href="#第一个方向" class="headerlink" title="第一个方向"></a>第一个方向</h4><ol>
<li>第一个想法</li>
</ol>
<p>还是用NSArray，但每次add的时候不直接add vc，而是add vc的弱引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__weak UIViewController *weakVC = vc;</div><div class="line">[array addObject: weakVC];</div></pre></td></tr></table></figure></p>
<p>这种方式仍然会强持有vc，因为虽然add到数组中的是弱引用的指针，但add本身影响的并不是指针的引用计数，而是所指向的堆上的内容的引用计数。所以无论add的strong还是weak的指针，NSArray总会增加它们所指向的堆上的内容的引用计数。</p>
<ol>
<li>对VC进行包装</li>
</ol>
<p>百度了一下发现 NSValue 貌似有个 valueWithNonretainedObject 方法，并且注释上看来正好是适合我们这种需求的类。<br><img src="http://atom-img.oss-cn-beijing.aliyuncs.com/93acc7dbae89c09fcaa0afbbc106ba8b.png" alt=""></p>
<p>尝试了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSValue *v = [NSValue valueWithNonretainedObject:vc];</div><div class="line">[array addObject: v];</div><div class="line">// ...vc释放之后</div><div class="line">NSValue *v = [array firstObject];</div><div class="line">UIViewController *vc = [v nonretainedObjectValue]; // crash</div></pre></td></tr></table></figure></p>
<p>代码直接挂在了从NSValue中取这个vc的地方，看信息是对一个dealloc的对象调用了retain方法，所以猜测可能调用 nonretainedObjectValue 的时候方法本身会对所包含的对象强持有一下（可能是保证取出的该对象可用？），但如果这样的话NSValue这个方法意义就不清楚了，所以暂时这个方法也不行。</p>
<ol>
<li>对vc进行另外一种包装</li>
</ol>
<p>这种方法算是第一个想法的升级版，虽然用__weak不行，但是可以构建一个新的wrapper对象，然后内部有一个weak的property指向vc，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Wrapper: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id weakRef;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">Wrapper *wrap = [Wrapper new];</div><div class="line">wrap.weakRef = vc;</div><div class="line">[array addObject:wrap];</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">[array firstObject].weakRef // nil</div></pre></td></tr></table></figure></p>
<p>可以满足要求，但缺点就是需要建立一个冗余的类型</p>
<hr>
<h4 id="第二个方向"><a href="#第二个方向" class="headerlink" title="第二个方向"></a>第二个方向</h4><p>百度了一下，发现iOS本身还是考虑到了这种需求的，内部有几个特殊的集合类型来满足复杂的内存管理需求。</p>
<p><strong>NSPointerArray，NSMapTable，NSHashTable</strong></p>
<p>只举例说明一下array类型，其余两种字典类型类似，可以参考文档使用</p>
<p>可以从字面上看到，NSPointerArray 内部保存的是对象的指针，并非直接保存OC对象。oc转指针就需要用到 bridge。同时 NSPointerArray 构建方法中通过传入NSPointerFunctionsOptions 来显示控制内存形式。<br><img src="http://atom-img.oss-cn-beijing.aliyuncs.com/5f8b2b1ec3fe07d688ed8d586a1dc0e4.png" alt=""><br>如果想达到要求的弱引用使用 NSPointerFunctionsWeakMemory 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSPointerArray *pa = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];</div><div class="line"></div><div class="line">[pa addPointer:(__bridge void*)vc];</div><div class="line"></div><div class="line">// …</div><div class="line"></div><div class="line">UIViewController *vc = [pa pointerAtIndex:0]; // vc is nil</div></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-01</span><i class="fa fa-comment-o"></i><a href="/posts/不强持有对象的集合/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://yhvh009.github.io/posts/不强持有对象的集合/,阳光夜风,不强持有对象的集合,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/posts/kvo跟KVOController/" title="kvo跟KVOController">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/posts/Associated-Object实现原理/" title="Associated Object实现原理">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'yhvh009-github-io';
var disqus_identifier = 'posts/不强持有对象的集合/';
var disqus_title = '不强持有对象的集合';
var disqus_url = 'https://yhvh009.github.io/posts/不强持有对象的集合/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>