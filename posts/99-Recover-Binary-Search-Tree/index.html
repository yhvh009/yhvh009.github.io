<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="阳光夜风"><title>LeetCode "99. Recover Binary Search Tree" · 阳光夜风</title><!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="description" content="LeetCode link
first thought
It’s similar to valid BST, using DFS to find the two invalid nodes and save them to a list.

solution
12345678910111213141"><meta name="keywords" content="iOS, Apple Foundation, Machine Learning, Algorithm, LeetCode"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">阳光夜风</a></h3><div class="description"><p>上善若水 大盈若冲</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/1685261185"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/categories/">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>LeetCode &quot;99. Recover Binary Search Tree&quot;</a></h3></div><div class="post-content"><p><a href="https://leetcode.com/problems/recover-binary-search-tree/description/" target="_blank" rel="external">LeetCode link</a></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h3 id="first-thought"><a href="#first-thought" class="headerlink" title="first thought"></a>first thought</h3><ul>
<li>It’s similar to valid BST, using DFS to find the two invalid nodes and save them to a list.</li>
</ul>
<p><strong>solution</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public void recoverTree(TreeNode root) &#123;</div><div class="line">        List&lt;TreeNode&gt; mistake = new ArrayList&lt;&gt;();</div><div class="line">        this.dfs(root, mistake, Integer.MIN_VALUE, Integer.MAX_VALUE);</div><div class="line">        if (mistake.size() == 2) &#123;</div><div class="line">            TreeNode m1 = mistake.get(0);</div><div class="line">            TreeNode m2 = mistake.get(1);</div><div class="line">            int temp = m1.val;</div><div class="line">            m1.val = m2.val;</div><div class="line">            m2.val = temp;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void dfs(TreeNode root, List&lt;TreeNode&gt; mistake, int min, int max) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (root.left != null &amp;&amp; (root.left.val &lt; min || root.left.val &gt; root.val)) &#123;</div><div class="line">            mistake.add(root.left);</div><div class="line">        &#125;</div><div class="line">        if (root.right != null &amp;&amp; (root.right.val &gt; max || root.right.val &lt; root.val)) &#123;</div><div class="line">            mistake.add(root.right);</div><div class="line">        &#125;</div><div class="line">        if (mistake.size() == 2) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        this.dfs(root.left, mistake, min, root.val);</div><div class="line">        this.dfs(root.right, mistake, root.val, max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>problem</strong></p>
<p>WA.</p>
<p><strong>reason</strong></p>
<p>Haven’t considered the invalid two nodes are one node and it’s child. In this case, the solution may only find one node.</p>
<hr>
<p><strong>modification</strong></p>
<p>Save parent node to the list. If there’s only two nodes, it represents the mistakes are parent and it’s child, then swap them. If there’s four nodes, then swap the two children.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public void recoverTree(TreeNode root) &#123;</div><div class="line">        List&lt;TreeNode&gt; mistake = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        this.dfs(root, mistake, Integer.MIN_VALUE, Integer.MAX_VALUE);</div><div class="line">        if (mistake.size() == 2) &#123;</div><div class="line">            TreeNode m1 = mistake.get(0);</div><div class="line">            TreeNode m2 = mistake.get(1);</div><div class="line">            int temp = m1.val;</div><div class="line">            m1.val = m2.val;</div><div class="line">            m2.val = temp;</div><div class="line">        &#125; else if (mistake.size() == 4) &#123;</div><div class="line">            TreeNode m1 = mistake.get(1);</div><div class="line">            TreeNode m2 = mistake.get(3);</div><div class="line">            int temp = m1.val;</div><div class="line">            m1.val = m2.val;</div><div class="line">            m2.val = temp;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void dfs(TreeNode root, List&lt;TreeNode&gt; mistake, int min, int max) &#123;</div><div class="line">        if (root == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (root.left != null &amp;&amp; (root.left.val &lt; min || root.left.val &gt; root.val)) &#123;</div><div class="line">            mistake.add(root);</div><div class="line">            mistake.add(root.left);</div><div class="line">        &#125;</div><div class="line">        if (root.right != null &amp;&amp; (root.right.val &gt; max || root.right.val &lt; root.val)) &#123;</div><div class="line">            mistake.add(root);</div><div class="line">            mistake.add(root.right);</div><div class="line">        &#125;</div><div class="line">        if (mistake.size() == 2) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        this.dfs(root.left, mistake, min, root.val);</div><div class="line">        this.dfs(root.right, mistake, root.val, max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>problem</strong></p>
<p>Still WA. And what’s more, recursion uses non-constant space.</p>
<p><strong>reason</strong></p>
<p>Maybe is the handle of the min and max.</p>
<hr>
<p>此处用到了 Morris Traversal，一个特别好的不用多余空间（包括栈跟递归）的遍历二叉树的方法，此处先说一下这个方法。</p>
<h3 id="Morris-Traversal"><a href="#Morris-Traversal" class="headerlink" title="Morris Traversal"></a>Morris Traversal</h3><p><strong>主要思想</strong></p>
<p>遍历树的关键就是怎么确定下一个遍历的节点，递归是通过特性来保证在访问某个节点的时候能够提前把它的所有子节点的遍历写出来，从而不用人为的特意保存该节点（感官上来说，其实考虑递归底层实现的话还是会有整个函数体的压栈跟出栈，保存的不仅仅是这个节点了，而是整个函数）；栈就是人为的主动保存该节点以及在合适的时候弹出该节点；而 Morris Traversal 则是利用树本身的一些特点来保存确定下个节点，以BST的中序遍历举例（相对简单，方便理解）。</p>
<p>先看一个树</p>
<p><img src="http://atom-img.oss-cn-beijing.aliyuncs.com/bdb4a3a4145ce517ee7e3fda634cac32.png" alt=""></p>
<p>中序遍历结果是：[1,2,3,4,5,6,7,8,9]</p>
<p>可以直观的发现（也是树中序遍历的必然结果）每个节点的前驱最右叶子节点即是中序遍历的前一个数字（根是6的时候前驱叶子是5，根是4的时候是3），可以根据这个特性来保存每个节点。因为是叶子节点，所以可以利用上叶子节点的右孩子来保存其下一个节点，当遍历到该叶子节点时，通过右孩子自然就会回到曾经的这个根节点上来。所以每个叶子的节点的右孩子都会是中序遍历中它的下一个数字，也是某个祖先节点。</p>
<p>保存方法：</p>
<ul>
<li>向左遍历</li>
<li>找到当前节点（a）的前驱最右叶子节点（b）</li>
<li>把 b 的右孩子设为当前节点</li>
<li>如果 b 的右孩子为当前节点，说明以a为根的左子树已经遍历完毕，则输出a，往右遍历</li>
</ul>
<ol>
<li>如 1，2，3，4，5，6，7，8，9</li>
<li>1-&gt;2,3,4,5-&gt;6,…</li>
<li>到2的时候发现1右等于2，说明2的左子树遍历完毕，输出2，则目前是1，2</li>
<li>遍历2的右：4</li>
<li>4往左遍历之后是1，2，3-&gt;4,5-&gt;6</li>
<li>4也结束，现在是1，2，3，4</li>
<li>遍历4的右：5</li>
<li>5左空，右是6，则输出5，现在是1，2，3，4，5</li>
<li>6的前驱右子是5，5的右是6自己，则输出6，并切断5的右子。</li>
<li>往6的右遍历。。。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public void inorderMorrisTraversal(TreeNode root) &#123;</div><div class="line">  List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">  TreeNode cur = root;</div><div class="line">  TreeNode temp = root;</div><div class="line">  while (cur != null) &#123;</div><div class="line">    if (cur.left != null) &#123;</div><div class="line">      temp = cur.left;</div><div class="line"></div><div class="line">      while (temp.right != null) &#123;</div><div class="line">        if (temp.right == cur) &#123;</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">        temp = temp.right;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (temp.right == null) &#123;</div><div class="line">        temp.right = cur;</div><div class="line">        cur = cur.left;</div><div class="line">      &#125; else &#123;</div><div class="line">        list.add(cur.val);</div><div class="line">        temp.right = null;</div><div class="line">        cur = cur.right;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">      list.add(cur);</div><div class="line">      cur = cur.right;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>modification</strong></p>
<p>根据 Morris Traversal，在遍历过程中缓存相邻两个node，如果前node大于后node，则该node为错误node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public void recoverTree(TreeNode root) &#123;</div><div class="line">        TreeNode first = null;</div><div class="line">        TreeNode second = null;</div><div class="line">        TreeNode cur = root;</div><div class="line">        TreeNode temp = root;</div><div class="line">        TreeNode preNode = null;</div><div class="line"></div><div class="line">        while (cur != null) &#123;</div><div class="line">            if (cur.left != null) &#123;</div><div class="line">                temp = cur.left;</div><div class="line"></div><div class="line">                while (temp.right != null) &#123;</div><div class="line">                    if (temp.right == cur) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    temp = temp.right;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (temp.right == null) &#123;</div><div class="line">                    temp.right = cur;</div><div class="line">                    cur = cur.left;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (preNode == null) &#123;</div><div class="line">                        preNode = cur;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (preNode.val &gt; cur.val) &#123;</div><div class="line">                            if (first == null) &#123;</div><div class="line">                                first = preNode;</div><div class="line">                                second = cur;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                second = cur;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    preNode = cur;</div><div class="line"></div><div class="line">                    temp.right = null;</div><div class="line">                    cur = cur.right;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (preNode == null) &#123;</div><div class="line">                    preNode = cur;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (preNode.val &gt; cur.val) &#123;</div><div class="line">                        if (first == null) &#123;</div><div class="line">                            first = preNode;</div><div class="line">                            second = cur;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            second = cur;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                preNode = cur;</div><div class="line"></div><div class="line">                cur = cur.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int tempVal = first.val;</div><div class="line">        first.val = second.val;</div><div class="line">        second.val = tempVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-23</span><i class="fa fa-comment-o"></i><a href="/posts/99-Recover-Binary-Search-Tree/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/算法/" title="算法">算法 </a><a class="tag" href="/tags/算法/" title="算法">算法 </a><a class="tag" href="/tags/algorithm/" title="algorithm">algorithm </a><a class="tag" href="/tags/LeetCode/" title="LeetCode">LeetCode </a><a class="tag" href="/tags/Tree/" title="Tree">Tree </a><a class="tag" href="/tags/树/" title="树">树 </a><a class="tag" href="/tags/Morris-Traversal/" title="Morris Traversal">Morris Traversal </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://yhvh009.github.io/posts/99-Recover-Binary-Search-Tree/,阳光夜风,LeetCode &quot;99. Recover Binary Search Tree&quot;,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/posts/297-Serialize-and-Deserialize-Binary-Tree/" title="LeetCode &quot;297. Serialize and Deserialize Binary Tree&quot;">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/posts/foundation/streams_sockets_and_ports/" title="流（Streams），Sockets和端口（Ports）">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'yhvh009-github-io';
var disqus_identifier = 'posts/99-Recover-Binary-Search-Tree/';
var disqus_title = 'LeetCode &quot;99. Recover Binary Search Tree&quot;';
var disqus_url = 'https://yhvh009.github.io/posts/99-Recover-Binary-Search-Tree/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>