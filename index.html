<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="阳光夜风"><title>阳光夜风</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords" content="iOS, Apple Foundation, Machine Learning, Algorithm, LeetCode"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">阳光夜风</a></h3><div class="description"><p>上善若水 大盈若冲</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/1685261185"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/categories/">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"></a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/GCD如何控制最大并发/">GCD如何控制最大并发</a></h3></div><div class="post-content"><p>NSOperation可以通过 maxConcurrentOperationCount 来控制并发数，而NSOperation又是基于GCD封装的，那么GCD怎么来控制并发呢？

通过信号量

把并发任务都放在一个串行队列中，然后每次取出一个任务来wait信号量，同时异步去执行，执行完毕之后再notify回来

...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-03</span><i class="fa fa-comment-o"></i><a href="/posts/GCD如何控制最大并发/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/GCD/" title="GCD">GCD </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/kvo跟KVOController/">kvo跟KVOController</a></h3></div><div class="post-content"><p>kvo实现原理系统会生成一个中间类，让对应对象的isa指向该中间类，同时系统在该中间类覆写setter方法，达到通知的目的

那成员变量等非property怎么办？

需要自己手动处理，方式也是类似的，自己手动设置setter方法，在setter方法中手动调用 willChangeValueForKey 跟 di...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-01</span><i class="fa fa-comment-o"></i><a href="/posts/kvo跟KVOController/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/不强持有对象的集合/">不强持有对象的集合</a></h3></div><div class="post-content"><p>前几天有同事在讨论想设计一个检查内存不释放的功能（主要是viewcontroller），大体思路就是每次pushviewcontroller的时候把vc加入到一个集合中，然后pop出去的时候延迟几秒之后在该集合内检查对应vc是否被释放。但是如果用普通的NSArray或者NSDictionary肯定是不行的，因为会...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-01-01</span><i class="fa fa-comment-o"></i><a href="/posts/不强持有对象的集合/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/Associated-Object实现原理/">Associated Object实现原理</a></h3></div><div class="post-content"><p>通过AssociationsManager来统一管理所有的associated objects。用一个导图就能很清楚的了解：

</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-27</span><i class="fa fa-comment-o"></i><a href="/posts/Associated-Object实现原理/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/Associated-Object/" title="Associated Object">Associated Object </a><a class="tag" href="/tags/AssociationsManager/" title="AssociationsManager">AssociationsManager </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/load跟initialize/">load跟initialize</a></h3></div><div class="post-content"><p>load系统加载load方法大致可以梳理成如下几步：

准备load方法
递归获取superclass，获取load方法，加入待加载class load方法表（所以父类的load在最前）
按照category编译顺序加载category中的load方法，加入到另一个待加载category load方法表


从头...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-27</span><i class="fa fa-comment-o"></i><a href="/posts/load跟initialize/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/load/" title="load">load </a><a class="tag" href="/tags/initialize/" title="initialize">initialize </a><a class="tag" href="/tags/runtime/" title="runtime">runtime </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/Bounds/">Bounds</a></h3></div><div class="post-content"><p>都知道bounds是相对于自己的坐标系，默认的bounds起点是(0, 0)。那改变bounds的position之后会产生什么结果呢？
1234567891011UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 280, 250)]...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-26</span><i class="fa fa-comment-o"></i><a href="/posts/Bounds/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/bounds/" title="bounds">bounds </a><a class="tag" href="/tags/frame/" title="frame">frame </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/Autorelease相关/">Autorelease相关</a></h3></div><div class="post-content"><p>
autorelease对象释放时机？

在当前runloop循环结束的时候，runloop会执行objc_autoreleasePoolPop(context)，这个操作才是真正释放autorelease对象的操作（具体实现后面会讲到）。或者是手动的@autoreleasepool{}结束之后，因为编译器会在@...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-26</span><i class="fa fa-comment-o"></i><a href="/posts/Autorelease相关/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/autorelease/" title="autorelease">autorelease </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/iOS-block高级用法-debounce跟throttle/">iOS block高级用法 - debounce跟throttle</a></h3></div><div class="post-content"><p>debounce跟throttle是其他语言中（如js）比较常见且常用的两个函数，直译就是防抖跟节流。debounce主要指在一定时间内重复调用某一函数，函数的执行会被一直推迟，直到在规定时间间隔内没有再触发该函数，才会去执行，同时只执行最后一次；throttle正好相反，是在某一时间内，只执行第一次。这么看可能...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-25</span><i class="fa fa-comment-o"></i><a href="/posts/iOS-block高级用法-debounce跟throttle/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/gcd/" title="gcd">gcd </a><a class="tag" href="/tags/block/" title="block">block </a><a class="tag" href="/tags/debounce/" title="debounce">debounce </a><a class="tag" href="/tags/throttle/" title="throttle">throttle </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/线程与队列/">GCD 线程与队列</a></h3></div><div class="post-content"><p>最近看到一个文章里面有这么一段话：每个应用都只有一个主线程，但主线程中可能有多个队列，则不仅仅只有主队列。突然发现自己对于线程跟队列这两个概念有些分辨不清，所以在这里重新梳理一下。
基本概念
队列：可以理解为一个FIFO的列表，里面装着需要执行的任务。gcd会从队列中取任务，然后放到对应的线程中去执行。

串行队...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-16</span><i class="fa fa-comment-o"></i><a href="/posts/线程与队列/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/多线程/" title="多线程">多线程 </a><a class="tag" href="/tags/gcd/" title="gcd">gcd </a><a class="tag" href="/tags/线程/" title="线程">线程 </a><a class="tag" href="/tags/队列/" title="队列">队列 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/posts/NSOperation/">NSOperation串行并行理解</a></h3></div><div class="post-content"><p>NSOperation是iOS中实现多线程的一个重要模块，在这里整理一些容易忽略或者模糊的点，不会有太多基础的知识。
先大致介绍一些基本知识。
核心的两个类 NSOperation 和 NSOperationQueue概述
NSOperation可以理解为待执行的任务。
NSOperationQueue是保存任务...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-09-16</span><i class="fa fa-comment-o"></i><a href="/posts/NSOperation/#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/categories/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/iOS/" title="iOS">iOS </a><a class="tag" href="/tags/NSOperation/" title="NSOperation">NSOperation </a><a class="tag" href="/tags/多线程/" title="多线程">多线程 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>